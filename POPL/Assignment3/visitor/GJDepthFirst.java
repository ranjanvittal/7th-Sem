//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class GJDepthFirst<R,A> implements GJVisitor<R,A> {
    //
    // Auto class visitors--probably don't need to be overridden.
    //
    public R visit(NodeList n, A argu) {
        R _ret = null;
        int _count = 0;
        for ( Enumeration<Node> e  =  n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
        }
        return _ret;
    }

    public R visit(NodeListOptional n, A argu) {
        if ( n.present() ) {
            R _ret = null;
            int _count = 0;
            for ( Enumeration<Node> e  =  n.elements(); e.hasMoreElements(); ) {
                e.nextElement().accept(this,argu);
                _count++;
            }
            return _ret;
        }
        else
            return null;
    }

    public R visit(NodeOptional n, A argu) {
        if ( n.present() )
            return n.node.accept(this,argu);
        else
            return null;
    }

    public R visit(NodeSequence n, A argu) {
        R _ret = null;
        int _count = 0;
        for ( Enumeration<Node> e  =  n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
        }
        return _ret;
    }

    public R visit(NodeToken n, A argu) { return null; }

    class MethodInfo {
        String argument_type;
        String return_type;
        public MethodInfo(String argument_type, String return_type) {
            this.argument_type = argument_type;
            this.return_type = return_type;
        }
    }

    class InterfaceMembers {
        Hashtable <String, MethodInfo> methods;
        public InterfaceMembers() {
            methods = new Hashtable <String, MethodInfo>();
        }
        public MethodInfo get(String method) {
            return methods.get(method);
        }
        public void put(String method, MethodInfo methodInfo) {
            methods.put(method, methodInfo);
        }
    }

    InterfaceMembers current;
    Hashtable<String, InterfaceMembers> all_interfaces;
    Set<String> already_checked;

    public boolean check_subtyping(String type1, String type2) {
        if(type1 == type2)
            return true;
        if(type1 == "int" || type1 == "boolean" || type1 == "void")
            return false;
        if(type2 == "int" || type2 == "boolean" || type2 == "void")
            return false;

        if(already_checked.contains(type1 + "_" + type2 + "_" + type1.length()))
            return true;
        already_checked.add(type1 + "_" + type2 + "_" + type1.length());
        InterfaceMembers in1 = all_interfaces.get(type1);
        InterfaceMembers in2 = all_interfaces.get(type2);
        Enumeration<String> methods = in2.methods.keys();
        while(methods.hasMoreElements()) {
            String method = methods.nextElement();
            MethodInfo methodInfo2 = in2.get(method);
            MethodInfo methodInfo1 = in1.get(method);
            if(methodInfo1 == null)
                return false;
            String arg1 = methodInfo1.argument_type;
            String arg2 = methodInfo2.argument_type;
            String res1 = methodInfo1.return_type;
            String res2 = methodInfo2.return_type;
            boolean arg = check_subtyping(arg2, arg1);
            boolean res = check_subtyping(res1, res2);
            if(!(arg && res)) {
                // if(!arg)
                //     System.out.println(arg2 + " <= " + arg1);
                // if(!res)
                //     System.out.println(res1 + " <= " + res2);
                return false;
            }
        }
        return true;
    }
    //
    // User-generated visitor methods below
    //

    /**
     * f0 -> ( Query() )*
     * f1 -> ( InterfaceDeclaration() )*
     * f2 -> <EOF>
     */
    public R visit(Goal n, A argu) {
        R _ret = null;
        all_interfaces = new Hashtable<String, InterfaceMembers>();
        n.f1.accept(this, argu);
        n.f2.accept(this, argu);
        n.f0.accept(this, argu);
        return _ret;
    }

    /**
     * f0 -> Identifier()
     * f1 -> "<="
     * f2 -> Identifier()
     * f3 -> "?"
     */
    public R visit(Query n, A argu) {
        R _ret = null;
        String type1 = (String) n.f0.accept(this, argu);
        String type2 = (String) n.f2.accept(this, argu);
        already_checked = new HashSet<String>();
        if(check_subtyping(type1, type2))
            System.out.println("Yes");
        else
            System.out.println("No");
        return _ret;
    }

    /**
     * f0 -> "interface"
     * f1 -> Identifier()
     * f2 -> InterfaceBody()
     */
    public R visit(InterfaceDeclaration n, A argu) {
        String interface1 = (String) n.f1.accept(this, argu);
        current = new InterfaceMembers();
        n.f2.accept(this, argu);
        all_interfaces.put(interface1, current);
        return null;
    }

    /**
     * f0 -> "{"
     * f1 -> ( InterfaceMember() )*
     * f2 -> "}"
     */
    public R visit(InterfaceBody n, A argu) {
        n.f1.accept(this, argu);
        return null;
    }

    /**
     * f0 -> ResultType()
     * f1 -> Identifier()
     * f2 -> "("
     * f3 -> Type()
     * f4 -> Identifier()
     * f5 -> ")"
     * f6 -> ";"
     */
    public R visit(InterfaceMember n, A argu) {
        String result_type = (String) n.f0.accept(this, argu);
        String method = (String) n.f1.accept(this, argu);
        String argument_type = (String) n.f3.accept(this, argu);
        current.put(method, new MethodInfo(argument_type, result_type));
        return null;
    }

    /**
     * f0 -> BooleanType()
     *         | IntegerType()
     *         | Identifier()
     */
    public R visit(Type n, A argu) {
        return n.f0.accept(this, argu);
    }

    /**
     * f0 -> "boolean"
     */
    public R visit(BooleanType n, A argu) {
        R _ret = (R) "boolean";
        return _ret;
    }

    /**
     * f0 -> "int"
     */
    public R visit(IntegerType n, A argu) {
        R _ret = (R) "int";
        return _ret;
    }

    /**
     * f0 -> VoidType()
     *         | Type()
     */
    public R visit(ResultType n, A argu) {
        return n.f0.accept(this, argu);
    }

    /**
     * f0 -> "void"
     */
    public R visit(VoidType n, A argu) {
        R _ret = (R) "void";
        return _ret;
    }

    /**
     * f0 -> <IDENTIFIER>
     */
    public R visit(Identifier n, A argu) {
      return (R) n.f0.toString();
    }

}
